stages:
    - build
    - imageBuildAndPush
    - deployDev
    - dt-event
    - imageBuildAndPush-validated
    - imageBuildAndPushStaging
    - release
    - deployStag
    - regcred-clean
    - stag-clean
    - deploy-clean
    - deploy-stag-clean

node-build:
    rules:
      - if: $CI_COMMIT_TAG == null
    stage: build
    image: node:8
    script:
        - npm install
        - npm list
    artifacts:
        paths:
            - "/builds/sockshop/front-end/node_modules/"

docker-buildnpush:
  rules:
      - if: $CI_COMMIT_TAG == null
  image: docker:27.2.0
  stage: imageBuildAndPush
  dependencies:
    - node-build
  #needs: ["monaco", "init_keptn"]
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 0
    DOCKER_DRIVER: overlay2
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    #important! MTU 1410 makes the MTU packages compatible with the underlying network. Otherwise, it will get stuck in downloads 
    DOCKER_DAEMON_OPTIONS: "--insecure-registry=$CI_REGISTRY --mtu=1410"
  services:
    - name: docker:27.2.0-dind
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
  before_script:
    - docker info
  script:
    - docker info
    - docker build -t $CI_REGISTRY_IMAGE:DEV-$CI_PIPELINE_IID .
    - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
    - docker push $CI_REGISTRY_IMAGE:DEV-$CI_PIPELINE_IID
    - echo "AUTH_TOKEN=$(sed -nE '$!{:a;N;$!ba;s/\n//g;s/"auth":[^"]*"([^"]*)"/\n\1\nAUTH/g};/^[^\n]*\nAUTH/P;D' ~/.docker/config.json)" >> auth.env
    - echo "$CI_PIPELINE_IID"
  artifacts:
        reports:
            dotenv: auth.env

deploy-to-dev:
    dependencies:
        - docker-buildnpush
        - node-build
    stage: deployDev
    image: alpine/kubectl:latest
    rules:
      - if: $CI_COMMIT_TAG == null
    script:
        - kubectl create secret docker-registry frontendregcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$AUTH_TOKEN
        - echo "$CI_DEPLOY_USER, $CI_DEPLOY_PASSWORD"
        - kubectl create secret docker-registry frontenddeploycred --docker-server=$CI_REGISTRY --docker-username=$CI_DEPLOY_USER --docker-password=$CI_DEPLOY_PASSWORD -n dev
        - 'sed -i "s#image: .*#image: $CI_REGISTRY_IMAGE:DEV-$CI_PIPELINE_IID#" manifest/front-end.yml'
        - "kubectl -n dev apply -f manifest/front-end.yml"
        - kubectl wait pod -l app=front-end  -n dev --for=condition=Ready --timeout=300s
        - kubectl delete secret frontendregcred
        - kubectl delete secret frontenddeploycred -n dev

dt-event-push:
    stage: dt-event
    rules:
      - if: $CI_COMMIT_TAG == null
    dependencies:
        - "deploy-to-dev"
    image: alpine/curl:8.14.1
    script:        
        - |
          curl -X "POST" "https://$DT_TENANT_UUID.live.dynatrace.com/api/v2/events/ingest" \
          --header "accept: application/json; charset=utf-8" \
          --header "Authorization: Api-Token $DT_ACCESS_TOKEN" \
          --header "Content-Type: application/json; charset=utf-8" \
          --data '{ "entitySelector": "type(SERVICE),tag(app:front-end),tag(environment:dev)", "eventType": "CUSTOM_INFO", "properties": { "Gitlab Build Number": " $CI_PIPELINE_IID ", "Git commit": " $CI_COMMIT_MESSAGE " }, "title": "Deployment Event" }'

docker-buildnpush-validated:
  rules:
      - if: $CI_COMMIT_TAG == null
  image: docker:27.2.0
  stage: imageBuildAndPush-validated
  dependencies:
    - node-build
    - deploy-to-dev
  #needs: ["monaco", "init_keptn"]
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 0
    DOCKER_DRIVER: overlay2
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    #important! MTU 1410 makes the MTU packages compatible with the underlying network. Otherwise, it will get stuck in downloads 
    DOCKER_DAEMON_OPTIONS: "--insecure-registry=$CI_REGISTRY --mtu=1410"
  services:
    - name: docker:27.2.0-dind
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
  before_script:
    - docker info
  script:
    - docker info
    - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
    - docker pull $CI_REGISTRY_IMAGE:DEV-$CI_PIPELINE_IID
    - docker tag $CI_REGISTRY_IMAGE:DEV-$CI_PIPELINE_IID $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest

docker-buildnpush-staging:
  image: docker:27.2.0
  stage: imageBuildAndPushStaging
  dependencies:
    - node-build
  rules:
    - if: $CI_COMMIT_TAG  
  #needs: ["monaco", "init_keptn"]
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 0
    DOCKER_DRIVER: overlay2
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    #important! MTU 1410 makes the MTU packages compatible with the underlying network. Otherwise, it will get stuck in downloads 
    DOCKER_DAEMON_OPTIONS: "--insecure-registry=$CI_REGISTRY --mtu=1410"
  services:
    - name: docker:27.2.0-dind
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
  before_script:
    - docker info
  script:
        - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
        - docker pull $CI_REGISTRY_IMAGE:latest
        - docker tag $CI_REGISTRY_IMAGE:latest $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        - echo "AUTH_TOKEN=$(sed -nE '$!{:a;N;$!ba;s/\n//g;s/"auth":[^"]*"([^"]*)"/\n\1\nAUTH/g};/^[^\n]*\nAUTH/P;D' ~/.docker/config.json)" >> auth.env
        - echo "$CI_PIPELINE_IID"
  artifacts:
        reports:
            dotenv: auth.env


release_job:
  stage: release
  dependencies:
        - node-build
        - docker-buildnpush-staging
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: $CI_COMMIT_TAG                 # Run this job when a tag is created
  script:
    - echo "running release_job"
  release:                               # See https://docs.gitlab.com/ee/ci/yaml/#release for available properties
    tag_name: '$CI_COMMIT_TAG'
    description: '$CI_COMMIT_TAG'

deploy-to-staging:
    dependencies:
        - docker-buildnpush
        - docker-buildnpush-staging
        - node-build
    stage: deployStag
    rules:
        - if: $CI_COMMIT_TAG 
    image: alpine/kubectl:latest
    script:
        - kubectl create secret docker-registry frontendregcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$AUTH_TOKEN
        - echo "$CI_DEPLOY_USER, $CI_DEPLOY_PASSWORD"
        - kubectl create secret docker-registry frontenddeploycred --docker-server=$CI_REGISTRY --docker-username=$CI_DEPLOY_USER --docker-password=$CI_DEPLOY_PASSWORD -n staging
        - 'sed -i "s#image: .*#image: $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG#" manifest/front-end.yml'
        - 'sed -i "s#namespace: .*#namespace: staging#" manifest/front-end.yml'
        - "kubectl -n staging apply -f manifest/front-end.yml"
        - kubectl delete secret frontendregcred
        - kubectl delete secret frontenddeploycred -n staging

regcred-cleaner:
    rules:
        - when: on_failure
        - if: $CI_COMMIT_TAG == null
    stage: regcred-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret frontendregcred
    allow_failure: true

deploy-cleaner:
    rules:
        - when: on_failure
        - if: $CI_COMMIT_TAG == null
    stage: deploy-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret frontenddeploycred -n dev
    allow_failure: true

deploy-stag-cleaner:
    rules:
        - when: on_failure
        - if: $CI_COMMIT_TAG 
    stage: deploy-stag-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret frontenddeploycred -n staging
    allow_failure: true

staging-cleaner:
    rules:
        - when: on_failure
        - if: $CI_COMMIT_TAG 
    stage: stag-clean
    image: alpine/kubectl:latest
    script:
        - "kubectl -n staging delete -f manifest/front-end.yml"
    allow_failure: true