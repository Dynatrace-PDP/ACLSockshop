stages:
    - build
    - imageBuildAndPush
    - deployDev
    - dt-event
    - jmeter-test
    - imageBuildAndPushStaging
    - deployStag
    - regcred-clean
    - stag-clean
    - deploy-clean
    - deploy-stag-clean

variables:
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"

go-build:
    stage: build
    image: dynatraceacm/gobuilder
    script:
        - export GOPATH=$PWD
        - mkdir -p src/github.com/dynatrace-sockshop/catalogue/
        - cp -R ./api src/github.com/dynatrace-sockshop/catalogue/
        - cp -R ./main.go src/github.com/dynatrace-sockshop/catalogue/
        - cp -R ./glide.* src/github.com/dynatrace-sockshop/catalogue/
        - cd src/github.com/dynatrace-sockshop/catalogue
        - glide install
        - go build -a -ldflags -linkmode=external -installsuffix cgo -o ./catalogue main.go
        - cd /builds/sockshop/catalogue/
        - echo "VERSION=$(cat version)" > vers.env
    artifacts:
        paths:
            - "/builds/sockshop/catalogue/src/github.com/dynatrace-sockshop/catalogue/"
        reports:
            dotenv: vers.env

dt-event-push:
    stage: dt-event
    dependencies:
        - "deploy-to-dev"
    image: alpine/curl:8.14.1
    script:        
        - |
          curl -X "POST" "https://$DT_TENANT_UUID.live.dynatrace.com/api/v2/events/ingest" --header "accept: application/json; charset=utf-8" --header "Authorization: Api-Token $DT_ACCESS_TOKEN" --header "Content-Type: application/json; charset=utf-8" --data '{ "entitySelector": "type(SERVICE),tag(app:catalogue),tag(environment:dev)", "eventType": "CUSTOM_INFO", "properties": { "Gitlab Build Number": "$CI_PIPELINE_IID", "Git commit": "$CI_COMMIT_MESSAGE" }, "title": "Deployment Event" }'

docker-buildnpush:
    dependencies:
        - go-build
    stage: imageBuildAndPush
    image: docker:24.0.5
    services:
        - name: docker:24.0.5-dind
          variables:
            HEALTHCHECK_TCP_PORT: "2376"
    before_script:
        - docker info
    script:
        - ls
        - docker build -t $CI_REGISTRY_IMAGE:$VERSION-$CI_PIPELINE_IID .
        - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
        - docker push $CI_REGISTRY_IMAGE:$VERSION-$CI_PIPELINE_IID
        - echo "AUTH_TOKEN=$(sed -nE '$!{:a;N;$!ba;s/\n//g;s/"auth":[^"]*"([^"]*)"/\n\1\nAUTH/g};/^[^\n]*\nAUTH/P;D' ~/.docker/config.json)" >> auth.env
        - echo "$CI_PIPELINE_IID"
    artifacts:
        reports:
            dotenv: auth.env

deploy-to-dev:
    dependencies:
        - docker-buildnpush
        - go-build
    stage: deployDev
    image: alpine/kubectl:latest
    script:
        - kubectl create secret docker-registry catalogueregcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$AUTH_TOKEN
        - echo "$CI_DEPLOY_USER, $CI_DEPLOY_PASSWORD"
        - kubectl create secret docker-registry cataloguedeploycred --docker-server=$CI_REGISTRY --docker-username=$CI_DEPLOY_USER --docker-password=$CI_DEPLOY_PASSWORD -n dev
        - 'sed -i "s#image: .*#image: $CI_REGISTRY_IMAGE:$VERSION-$CI_PIPELINE_IID#" manifest/catalogue.yml'
        - "kubectl -n dev apply -f manifest/catalogue.yml"
        - kubectl wait pod -l app=catalogue  -n dev --for=condition=Ready --timeout=300s
        - kubectl delete secret catalogueregcred
        - kubectl delete secret cataloguedeploycred -n dev

jmeter-tests:
    dependencies:
        - go-build
    needs:
        - deploy-to-dev
        - go-build
    stage: jmeter-test
    image: dynatraceace/jmeter-runner:1.0.0-acl
    script:
        - /jmeter/bin/jmeter.sh -n -t jmeter/basiccheck.jmx -l HealthCheck_catalogue_dev_$VERSION-$CI_PIPELINE_IID -JSERVER_URL=catalogue.dev -JSERVER_PORT=80 -JCHECK_PATH "/health" -JVUCount=1 -JLoopCount=1 -JDT_LTN="HealthCheck_1" -JTestDuration='120' -JThinkTime='250' > Basicresults.txt
        - RESULT=$(awk '/Err:\s*/{print $15}' Basicresults.txt)
        - GOAL="0"
        - echo $RESULT
        - RESULT=$(echo "$RESULT")
        - if [ $RESULT != $GOAL ]; then cat BasicResults.txt && echo "jmeter returned error" && exit 63; fi
        - /jmeter/bin/jmeter.sh -n -t jmeter/catalogue_load.jmx -l FuncCheck_catalogue_dev_$VERSION-$CI_PIPELINE_IID -JSERVER_URL=catalogue.dev -JSERVER_PORT=80 -JCHECK_PATH "/health" -JVUCount=1 -JLoopCount=1 -JDT_LTN="FuncCheck_1" -JTestDuration='120' -JThinkTime='250' > Funcresults.txt
        - RESULT=$(awk '/Err:\s*/{print $15}' Funcresults.txt)
        - echo $RESULT
        - RESULT=$(echo "$RESULT")
        - if [ $RESULT != $GOAL ]; then cat FuncResults.txt && echo "jmeter returned error" && exit 63; fi

docker-buildnpush-staging:
    dependencies:
        - jmeter-tests
        - go-build
    stage: imageBuildAndPushStaging
    image: docker:24.0.5
    services:
        - name: docker:24.0.5-dind
          variables:
            HEALTHCHECK_TCP_PORT: "2376"
    before_script:
        - docker info
    script:
        - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
        - docker pull $CI_REGISTRY_IMAGE:$VERSION-$CI_PIPELINE_IID
        - docker tag $CI_REGISTRY_IMAGE:$VERSION-$CI_PIPELINE_IID $CI_REGISTRY_IMAGE:$VERSION
        - docker push $CI_REGISTRY_IMAGE:$VERSION
        - echo "AUTH_TOKEN=$(sed -nE '$!{:a;N;$!ba;s/\n//g;s/"auth":[^"]*"([^"]*)"/\n\1\nAUTH/g};/^[^\n]*\nAUTH/P;D' ~/.docker/config.json)" >> auth.env

deploy-to-staging:
    dependencies:
        - docker-buildnpush
        - docker-buildnpush-staging
        - go-build
    stage: deployStag
    image: alpine/kubectl:latest
    script:
        - kubectl create secret docker-registry catalogueregcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$AUTH_TOKEN
        - echo "$CI_DEPLOY_USER, $CI_DEPLOY_PASSWORD"
        - kubectl create secret docker-registry cataloguedeploycred --docker-server=$CI_REGISTRY --docker-username=$CI_DEPLOY_USER --docker-password=$CI_DEPLOY_PASSWORD -n staging
        - 'sed -i "s#image: .*#image: $CI_REGISTRY_IMAGE:$VERSION#" manifest/catalogue.yml'
        - 'sed -i "s#namespace: .*#namespace: staging#" manifest/catalogue.yml'
        - "kubectl -n staging apply -f manifest/catalogue.yml"
        - kubectl wait pod -l app=catalogue  -n staging --for=condition=Ready --timeout=300s
        - kubectl delete secret catalogueregcred
        - kubectl delete secret cataloguedeploycred -n staging

regcred-cleaner:
    rules:
        - when: on_failure
    stage: regcred-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret catalogueregcred
    allow_failure: true

deploy-cleaner:
    rules:
        - when: on_failure
    stage: deploy-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret cataloguedeploycred -n dev
    allow_failure: true

deploy-stag-cleaner:
    rules:
        - when: on_failure
    stage: deploy-stag-clean
    image: alpine/kubectl:latest
    script:
        - kubectl delete secret cataloguedeploycred -n staging
    allow_failure: true

staging-cleaner:
    rules:
        - when: on_failure
    stage: stag-clean
    image: alpine/kubectl:latest
    script:
        - "kubectl -n staging delete -f manifest/catalogue.yml"
    allow_failure: true